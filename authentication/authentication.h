/*
* Authentication: Takes care of user authentication and access control.
*/

#ifndef AUTHENTICATION_H
#define AUTHENTICATION_H

#include <filesystem>
#include <fstream>
#include <iostream>
#include <random>
#include <regex>
#include <string>

#include "encryption/encryption.h"
#include "helpers/helper_functions.h"

enum UserType {
    admin = 0,
    user = 1
};

/// Add a user to the system
/// \param userName     The username to add
/// \param directory    The directory to add the user to
/// \param isAdmin    Whether the user is an admin
void addUser(const std::string& userName, std::string directory, bool isAdmin= false)
{
    std::string normalizedDir = directory + "/";
    if (userName.length() > 50) {
        std::cout << "Error: Username is too long." << std::endl;
        return;
    }
    if (!isAdmin && userName == "admin") {
        std::cout << "Error: Invalid Username." << std::endl;
        return;
    }

    std::regex validUsernameRegex("^[a-zA-Z0-9]*$");
    if (!std::regex_match(userName, validUsernameRegex)) {
        std::cout << "Error: Username contains invalid characters." << std::endl;
        return;
    }

    // Check if user already exists
    std::string publicKeyPath = normalizedDir + "key/public_keys/" + userName + ".pub";
    std::string privateKeyPath = normalizedDir + "key/private_keys/" + userName + "_keyfile";
    if (std::filesystem::exists(publicKeyPath) || std::filesystem::exists(privateKeyPath)) {
        std::cout << "User " << userName << " already exists." << std::endl;
        return;
    }

    // Generate SSH key pair
    std::string privateKeyFile = normalizedDir + "key/private_keys/" + userName;
    std::string generateKeyCommand = "ssh-keygen -t rsa -b 2048 -C 'created_by_encrypted_fs' -f " + privateKeyFile + " -N '' -q";
    system(generateKeyCommand.c_str());

    // Move and rename key files
    std::filesystem::rename(privateKeyFile + ".pub", publicKeyPath);
    std::filesystem::rename(privateKeyFile, privateKeyPath);

    // Post-creation steps
    std::cout << "User " << userName << " added successfully." << std::endl;

    // Create metadata key file if not present
    std::fstream file(normalizedDir + "/common/" + userName + "_key", std::ios::out | std::ios::binary);
    if (!file.is_open()) {
        std::cout << "Failed to create user metadata key file" << std::endl;
        return;
    }

    // Create 256-bit key
    uint8_t key[KEY_SIZE];
    RAND_bytes(key, KEY_SIZE);
    file.write((char *) key, KEY_SIZE);
    file.close();

    std::ofstream outfile(normalizedDir + "common/user_list", std::ios_base::app);
    outfile << userName << "\n";
    outfile.close();
    createInitFsForUser(userName, normalizedDir);
}

/// Check if a keyfile is valid
/// \param userName    The username to check
/// \return
bool isValidKeyfile(const std::string& userName)
{
    // Define paths for the user's private and public keys
    std::filesystem::path privateKeyPath = "key/private_keys/" + userName + "_keyfile";
    std::filesystem::path publicKeyPath = "key/public_keys/" + userName + ".pub";

    // Generate the expected public key from the private key file using ssh-keygen
    std::string extractPublicKeyCmd = "ssh-keygen -y -f " + privateKeyPath.string();
    std::array<char, 128> buffer;
    std::string expectedPublicKey;
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(extractPublicKeyCmd.c_str(), "r"), pclose);
    if (!pipe) {
        std::cerr << "Failed to run command: " << extractPublicKeyCmd << std::endl;
        return false;
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        expectedPublicKey.append(buffer.data());
    }

    // Read the actual public key from file
    std::ifstream publicKeyFile(publicKeyPath);
    std::string actualPublicKey((std::istreambuf_iterator<char>(publicKeyFile)), std::istreambuf_iterator<char>());

    // Verify the public key is correctly generated by the system
    bool isCreatedByEncryptedFs = actualPublicKey.find("created_by_encrypted_fs") != std::string::npos;

    // Check if the user is listed in the system's user list
    bool isUserListed = false;
    std::ifstream userList("common/user_list");
    std::string line;
    while (getline(userList, line)) {
        if (line.find(userName) != std::string::npos) {
            isUserListed = true;
            break;
        }
    }
    // The keyfile is valid if the extracted public key matches the stored one, it's correctly flagged, and the user is listed
    return expectedPublicKey == actualPublicKey && isCreatedByEncryptedFs && isUserListed;
}

/// Get the type of user from a keyfile
/// \param keyFileName    The name of the keyfile
/// \return          The type of user
std::string getTypeOfUser(const std::string& keyFileName)
{
    // Attempt to get file status; if unsuccessful, terminate the program
    struct stat fileInfo;
    std::string privateKeyPath = "key/private_keys/" + keyFileName;
    if (stat(privateKeyPath.c_str(), &fileInfo) != 0) {
        std::cerr << "Invalid keyfile" << std::endl;
        exit(EXIT_FAILURE); // Consider throwing an exception instead of exiting
    }

    // Extract username from the keyfile name by removing the suffix and any spaces
    std::string userName = keyFileName.substr(0, keyFileName.find_first_of("_ "));

    // Validate the keyfile based on the extracted username
    if (isValidKeyfile(userName)) {
        std::cout << "Logged in as " << userName << std::endl;
        return userName;
    }

    // If validation fails, report an invalid keyfile and terminate the program
    std::cerr << "Invalid keyfile" << std::endl;
    exit(EXIT_FAILURE); // Consider throwing an exception instead of exiting
}

#endif // AUTHENTICATION_H
